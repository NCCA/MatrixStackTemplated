#ifndef MATRIXSTACK_H_
#define MATRIXSTACK_H_
#include <ngl/Mat3.h>
#include <ngl/Mat4.h>
#include <iostream>
#include <ngl/NGLStream.h>

#include <array>
//----------------------------------------------------------------------------------------------------------------------
/// @brief Simple Matrix Stack for Old school OpenGL
/// transformations in a modern GL context
//----------------------------------------------------------------------------------------------------------------------
template <typename T, std::size_t stackSize>
class MatrixStack
{
public:
  //----------------------------------------------------------------------------------------------------------------------
  /// @brief ctor can set depth
  /// @param _depth stack size default 40
  //----------------------------------------------------------------------------------------------------------------------
  MatrixStack() = default;
  //----------------------------------------------------------------------------------------------------------------------
  /// @brief push the current value of top onto
  /// the stack
  //----------------------------------------------------------------------------------------------------------------------
  void pushMatrix()
  {
    if (++m_top < m_depth)
    {
      // copy the matrix to the top of stack
      m_stack[m_top] = m_stack[m_top - 1];
    }
    else
    {
      std::cerr << "Matrix stack overflow\n";
      exit(EXIT_FAILURE);
    }
  }
  //----------------------------------------------------------------------------------------------------------------------
  /// @brief pop the current top of stack and replace
  /// with last
  //----------------------------------------------------------------------------------------------------------------------
  void popMatrix()
  {
    m_stack[m_top].identity();
    if (--m_top < 0)
    {
      std::cerr << "Matrix stack underflow \n";
      exit(EXIT_FAILURE);
    }
  }
  //----------------------------------------------------------------------------------------------------------------------
  /// @brief similar to glIdentity() will reset top of stack (but not view)
  //----------------------------------------------------------------------------------------------------------------------
  void identity() { m_stack[m_top].identity(); }

  //----------------------------------------------------------------------------------------------------------------------
  /// @brief return the matrix at the top of the stack
  /// @returns ngl::Mat4 the current top of stack model
  /// transform
  //----------------------------------------------------------------------------------------------------------------------
  ngl::Mat4 top() const { return m_stack[m_top]; }
  //----------------------------------------------------------------------------------------------------------------------
  /// @brief set the view matrix which will be post multiplied by current model
  /// and project matrix
  /// @param _v the view matrix to use
  //----------------------------------------------------------------------------------------------------------------------
  void setView(const ngl::Mat4 &_v) { m_view = _v; }
  //----------------------------------------------------------------------------------------------------------------------
  /// @brief set the projection matrix which will be post multiplied by current model
  /// and model matrix
  /// @param _v the view projection matrix to use
  //----------------------------------------------------------------------------------------------------------------------
  void setProjection(const ngl::Mat4 &_p) { m_projection = _p; }
  //----------------------------------------------------------------------------------------------------------------------
  /// @brief create a rotation using x,y,z rolls
  /// @param _x the x rotation in degrees
  /// @param _y the x rotation in degrees
  /// @param _z the x rotation in degrees
  /// @note this is done as follows
  ///  ngl::Mat4 final=z*y*x; where each is a rotation matrix
  //----------------------------------------------------------------------------------------------------------------------
  void rotate(float _x, float _y, float _z)
  {
    auto x = ngl::Mat4::rotateX(_x);
    auto y = ngl::Mat4::rotateY(_y);
    auto z = ngl::Mat4::rotateZ(_z);
    ngl::Mat4 final = z * y * x;
    m_stack[m_top] *= final;
  }
  //----------------------------------------------------------------------------------------------------------------------
  /// @brief axis angle rotation like glRotate
  /// @param _angle the angle of rotation in degrees
  /// @param _x axis value
  /// @param _y axis value
  /// @param _z axis value
  /// @note this works like glRotate so we could do
  /// rotate(45,0,1,0) to rotate 45 degrees in the Y
  //----------------------------------------------------------------------------------------------------------------------
  void rotate(float _angle, float _x, float _y, float _z)
  {
    auto r = ngl::Mat4::euler(_angle, _x, _y, _z);
    m_stack[m_top] *= r;
  }
  //----------------------------------------------------------------------------------------------------------------------
  /// @brief translate similar to glTranslate
  /// @param _x the x translation
  /// @param _y the x translation
  /// @param _z the x translation
  //----------------------------------------------------------------------------------------------------------------------
  void translate(float _x, float _y, float _z)
  {
    auto t = ngl::Mat4::translate(_x, _y, _z);
    m_stack[m_top] *= t;
  }
  //----------------------------------------------------------------------------------------------------------------------
  /// @brief scale similar to glScale a uniform scale around the origin
  /// @param _x the x scale
  /// @param _y the x scale
  /// @param _z the x scale
  //----------------------------------------------------------------------------------------------------------------------
  void scale(float _x, float _y, float _z)
  {
    auto s = ngl::Mat4::scale(_x, _y, _z);
    m_stack[m_top] *= s;
  }
  //----------------------------------------------------------------------------------------------------------------------
  /// @brief get the Model View Project matrix
  /// @returns the MVP matrix product
  //----------------------------------------------------------------------------------------------------------------------
  T MVP() const
  {
    return m_projection * m_view * m_stack[m_top];
  }
  //----------------------------------------------------------------------------------------------------------------------
  /// @brief get the Model View  matrix
  /// @returns the MV matrix product
  //----------------------------------------------------------------------------------------------------------------------
  T MV() const
  {
    return m_view * m_stack[m_top];
  }

private:
  //----------------------------------------------------------------------------------------------------------------------
  /// @brief make this non-copyable
  //----------------------------------------------------------------------------------------------------------------------
  MatrixStack(const MatrixStack &) = delete;
  //----------------------------------------------------------------------------------------------------------------------
  /// @brief make this non-copyable
  //----------------------------------------------------------------------------------------------------------------------
  MatrixStack operator=(const MatrixStack &) = delete;
  //----------------------------------------------------------------------------------------------------------------------
  /// @brief the actual stack
  //----------------------------------------------------------------------------------------------------------------------
  std::array<T, stackSize> m_stack;
  //----------------------------------------------------------------------------------------------------------------------
  /// @brief the top of the stack
  //----------------------------------------------------------------------------------------------------------------------
  size_t m_top = 0;
  //----------------------------------------------------------------------------------------------------------------------
  /// @brief the depth of the stack
  //----------------------------------------------------------------------------------------------------------------------
  size_t m_depth = stackSize;
  //----------------------------------------------------------------------------------------------------------------------
  /// @brief view matrix
  //----------------------------------------------------------------------------------------------------------------------
  T m_view;
  //----------------------------------------------------------------------------------------------------------------------
  /// @brief projection matrix
  //----------------------------------------------------------------------------------------------------------------------
  T m_projection;
};

#endif
